"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resolveUnions;
var _lodash = require("lodash");
var _aliases = require("./aliases");
var _util = require("./util");
const moveProp = (obj, qualifiedName, fieldName) => {
  const qualifiedValue = obj[qualifiedName];
  delete obj[qualifiedName];
  if (!qualifiedValue) return;
  if (obj[fieldName] == null) {
    obj[fieldName] = qualifiedValue;
    return;
  }
  if ((0, _lodash.isObject)(obj[fieldName])) {
    Object.assign(obj[fieldName], qualifiedValue);
  } else if ((0, _util.isEmptyArray)(obj[fieldName]) && !(0, _util.isEmptyArray)(qualifiedValue)) {
    obj[fieldName] = qualifiedValue;
  }
};
function resolveUnions(data, sqlAST) {
  if (!data || Array.isArray(data) && data.length === 0) {
    return;
  }
  if (sqlAST.type === 'union') {
    for (let typeName in sqlAST.typedChildren) {
      const suffix = '@' + typeName;
      const children = sqlAST.typedChildren[typeName];
      for (let child of children) {
        const isConflicting = (0, _aliases.hasConflictingSiblings)(child, sqlAST.typedChildren[typeName]) && !child.sqlBatch;
        const fieldName = isConflicting ? (0, _aliases.getAliasKey)(child.fieldName, child.alias) : child.fieldName;
        const qualifiedName = isConflicting ? (0, _aliases.getAliasKey)(child.fieldName + suffix, child.alias) : child.fieldName + suffix;
        if (Array.isArray(data)) {
          for (let obj of data) {
            moveProp(obj, qualifiedName, fieldName);
          }
          if (child.type === 'table' || child.type === 'union') {
            const nextLevelData = (0, _lodash.chain)(data).filter(obj => obj != null).flatMap(obj => obj[fieldName]).filter(obj => obj != null).value();
            resolveUnions(nextLevelData, child);
          }
        } else {
          moveProp(data, qualifiedName, fieldName);
          if (child.type === 'table' || child.type === 'union') {
            resolveUnions(data[fieldName], child);
          }
        }
      }
    }
  }
  if (sqlAST.type === 'table' || sqlAST.type === 'union') {
    for (let child of sqlAST.children) {
      if ((child.type === 'table' || child.type === 'union') && !child.sqlBatch) {
        const isConflicting = (0, _aliases.hasConflictingSiblings)(child, sqlAST.children);
        const fieldName = isConflicting ? (0, _aliases.getAliasKey)(child.fieldName, child.alias) : child.fieldName;
        if (Array.isArray(data)) {
          const nextLevelData = (0, _lodash.chain)(data).filter(obj => obj != null).flatMap(obj => obj[fieldName]).filter(obj => obj != null).value();
          resolveUnions(nextLevelData, child);
        } else {
          resolveUnions(data[fieldName], child);
        }
      }
    }
  }
}